<binary digit> ::= '0' | '1'
<decimal digit> ::= <binary digit> | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
<hexadecimal digit> ::= <decimal digit> | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
<byte> ::= <hexadecimal digit> <hexadecimal digit>
<decimal number> ::= <decimal digit> {'decimal digit'}
<hexadecimal number> ::= '0' ('x' | 'X') <hexadecimal number> {<hexadecimal number>}
<binary number> ::= '0' ('b' | 'B') <binary number> {<binary number>}
<character code> ::= "'<any character>'"
<floating point number> ::= <decimal number>'.'[<decimal number>]
<real number> ::= ['-'] (<floating point number> | <floating point number> ('e' | 'E') ['+' | '-'] <decimal number>) ['d' | 'D']
<natural number> ::= <decimal number> | <hexadecimal number> | <binary number> | <character code>
<integer number> ::= ['-'] <natural number> ['l' | 'L']
<number> ::= <integer number> | <floating point number> | <real number>
<letter> ::= 'A' | 'B' | ... | 'Z' | 'a' | 'b' | ... | 'z' | 0x80 | 0x81 | ... | 0xFF
<space> ::= 0x20
<tabulation> ::= 0x09
<end-of-line> ::= 0x0D 0x0A
<delimiter> ::= '!' | '"' | '#' | '$' | '%' | '&' | ''' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '<' | '=' | '>' | '?' | '@' | '[' | '\' | ']' | '^' | '_' | '|' | '}' | '{' | '~' | <tabulation> | <space> | <end-of-line>
<character> ::= <decimal digit> | <letter> | <delimiter>
<name> ::= (<letter> | '_') {<letter> | '_' | <decimal digit>}
<function name> ::= <name>
<variable name> ::= <name>
<type name> ::= <name>
<field name> ::= <name>
<method name> ::= <name>
<attribute name> ::= <name>
<macro name> ::= <name>
<str character> ::= <tabulation> | <space> | '!' | '#' | ... | '[' | ']' | ... | 0xFF
<ext str character> ::= <str character> | '\'
<any character> ::= <ext str character> | '"'
<macrostring element> ::= {<str character>|<end-of-line>| '$'<macro name>}
<const string element> ::= <str character> | <end-of-line> | '\\' | '\"' | '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\l' | '\0'<byte> | '\$'<macro name>'$' | '\$"' {<macrostring element>} '"' | '\#' | '\=' ( '\' | '/' | '~' | '^' | '&' | ':') | '\%['[ {<ext str character>} ]']'{<ext str character>}[{<ext str character>}] | '\[' {<any character>}']' | '\<'{<macrostring element>}'>'
<string element> ::= {<ext str character>} | '\('<expression>')'
<const string> ::= '"' { <const string element> | '\!'{<const string element>| '"'}'\!' }'"'
<string> ::= '"' { <string element>| '\!'{<string element>| '"'}'\!' }'"'
<const binary data element> ::= '\h'<space> [ ( '2' | '4' | '8' ) <space>] | '\i'<space> [ ( '2' | '4' | '8' ) <space>] | <hexadecimal digit> {<hexadecimal digit>} { (<space> | ',' | <end-of-line>) <hexadecimal digit> {<hexadecimal digit>} } | <integer number> { (<space> | ',' | <end-of-line>) <integer number> } | '\'<const string> | '\[' {<any character>}']' | '\$'<macro name>'$' | '\$"' {<macrostring element>} '"' | '\<'{<macrostring element>}'>'
<binary data element> ::= <const binary data element> | '\('<expression>')'
<const binary data> ::= ''' {<const binary data element>} '''
<binary data> ::= ''' {<binary data element>} '''
<const collection> ::= '%{' <constant> {','<constant>} '}'
<collection> ::= '%{' <expression> {','<expression>} '}'
<constant> ::= <number> | <const string> | <const binary data> | <const collection>
<array> ::= [ '[' {','} ']' ] [<type name>]
<object> ::= <variable name> | <pointer> | <array element> | <field> | <function call> | <method call> | <expression> | <late binding>
<pointer> ::= <expression> '->' <type name> [<array>]
<parameters> ::= <expression> {','<expression>}
<array element> ::= <object>'['<parameters>']'
<field> ::= [<object>]'.'<field name>
<late binding> ::=<object>'~' (<field name> | <method name>'(' [<parameters>] ')')
<function call> ::= (<function name> | <expression>'->''func' ) '(' [<parameters>] ')'
<method call> ::= [<object>]'.'<method name>'(' [<parameters>] ')'
<lvalue> ::= <object> | <variable name> | <pointer> | <array element> | <field>
<as operation> ::= <variable name>'as' ((<type name>[<array>]) | <object>)
<operand> ::= <lvalue> | <constant> | <string> | <binary data> | <collection> | <function call> | <method call> | <type name> | <late binding>
<increment operator> ::= '++' | '--'
<assignment operator> ::= '=' | '%=' | '&=' | '*=' | '+=' | '-=' | '/=' | '<<=' | '>>=' | '^=' | '|='
<unary operator> ::= '+' | '-' | '*' | '!' | '~' | '@'
<binary operator> ::= '==' | '!=' | '>' | '<' | '<=' | '>=' | '&&' | '||' | '&' | '%' | '*' | '/' | '+' | '-' | '<<' | '>>' | '^' | '%==' | '%!=' | '%>' | '%<' | '%<=' | '%>=' | '@'
<operator> ::= <increment operator> | <assignment operator> | <unary operator> | <binary operator>
<assignment expression> ::= <lvalue><assignment operator><expression>
<lvalue expression> ::= '&'<lvalue> | '&'<function name> | <increment operator><lvalue> | <lvalue><increment operator>
<question> ::= '?''(' <expression>',' [<expression>] ',' [<expression>] ')'
<expression> ::= <operand> | <assignment expression> | <lvalue expression> | <expression><binary operator> [<end-of-line>] <expression> | '('<expression>')' | <unary operator><expression> | <as operation> | <question>
<variable declaration> ::= <variable name> ['['<expression> { [','] <expression>} ']'] [of <type name>]
<variable list> ::= <variable declaration> ['='<expression>','<variable list>] | <variable declaration> [[',']<variable list>]
<variables declaration> ::= <type name><variable list><end-of-line>
<if> ::= if <expression><block> {elif <expression> <block>} [else <block>]
<while> ::= while <expression><block>
<dowhile> ::= do <block> while <expression>
<for> ::= for [<expression>] ','<expression>',' [<expression>] <block>
<fornum> ::= fornum <variable name> ['='<expression>] ','<expression><block>
<foreach> ::= foreach [<type name>] <variable name> [<array>]','<expression><block>
<return> ::= return [<expression>]
<label> ::= label <name>
<goto> ::= goto <name>
<switch> ::= switch <expression>'{' {case <expression> {','<expression>} {<label>} <block>} [default {<label>} <block>] '}'
<block contents> ::= <block command> {<end-of-line><block command>}
<block> ::= '{'<block contents>'}'
<block command> ::= {<label>} (<block> | <expression> | <variables declaration> | <if> | <for> | <fornum> | <while> | <dowhile> | <foreach> | <switch> | break | continue | <return>)
<parameter declaration> ::= <variable name> [<array>]
<parameters declaration> ::= <type name><parameter declaration> { [','] <parameter declaration>} [<parameters declaration>]
<attributes> ::= '<'<attribute name> { [','] <attribute name>} '>'
<subfunction> ::= subfunc [<type name>] <function name> ['(' [<parameters declaration>] ')'] <block>
<function body> ::= '{' (<block command> | <subfunction>) <block command> {<end-of-line> (<block command> | <subfunction>) } '}'
<function declaration> ::= func [<type name>] <function name> [<attributes>] ['(' [<parameters declaration>] ')']
<func> ::= <function declaration><function body>
<method declaration> ::= method [<type name>] <type name>'.'<method name>[<attributes>] ['(' [<parameters declaration>] ')']
<method> ::= <method declaration><function body>
<property declaration> ::= property [<type name>] <type name>'.'<method name> [<attributes>] ['(' [<parameters declaration>] ')']
<property> ::= <property declaration><function body>
<operator declaration> ::= operator <type name> <operator> [<attributes>] '(' <parameters declaration> ')'
<operator function> ::= <operator declaration><function body>
<text-function declaration> ::= text <function name> [<attributes>]['(' [<parameters declaration>] ')']
<text-function body> ::= { <const string element> | '\@'<function name>'(' [<parameters>]> | '\('<expression>')' | '\{'(<block command> | <subfunction>) <block command> {<end-of-line> (<block command> | <subfunction>) }'}' }['\!']
<text> ::= <text-function declaration><end-of-line><text-function body>
<macro declaration> ::= <macro name> ['=' (<constant>|<name>) ]
<define> ::= define [<name>][<attributes>] '{'<macro declaration> {<end-of-line><macro declaration>} '}'
<macro expression> ::= '$'<macro name> | <constant> | '!'<macro expression> | '('<macro expression>')' | <macro expression> ( '&&' | '||' | '==' | '!=' ) <macro expression>
<ifdef> ::= ifdef <macro expression> '{' ... '}' { elif <macro expression> '{' ... '}' } [ else '{' ... '}']
<file name> ::= '"' {<str character>} '"'
<include> ::= include '{'<file name> {<end-of-line><file name>} '}'
<imported function declaration> ::= [ <type name> ] <function name> '(' [ <type name> { ','<type name> } ] ')' [ '->' <function name>]
<import> ::= import <file name> [<attributes>] '{' <imported function declaration> { <end-of-line><imported function declaration> } '}'
<field declaration> ::= <field declaration> [<array declaration>]
<fields declaration> ::= <type name><field declaration> {[','] <field declaration>}<end-of-line>
<type> ::= type [<attributes>] '{'<fields declaration>{<fields declaration>} '}'
<array declaration> ::= ['['<natural number> { [','] <natural number>} ']'] [of <type name>]
<global variable declaration> ::= <variable name> [<array declaration>]['=' <constant> ]
<global variables declaration> ::= <type name><global variable declaration> {[','] <global variable declaration>}<end-of-line>
<global> ::= global '{' {<global variables declaration>} '}'
<public> ::= public
<private> ::= private
<extern> ::= extern '{' {(<function declaration> | <method declaration> | <operator declaration> | <property declaration> )<end-of-line>} '}'
<command> ::= <define> | <func> | <method> | <text> | <operator function> | <property> | <include> | <type> | <global> | <extern> | <import> | <public> | <private> | <ifdef>
<program> ::= <command> {<end-of-line><command>}
